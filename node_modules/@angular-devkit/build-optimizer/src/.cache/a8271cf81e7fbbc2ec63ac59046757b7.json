{"remainingRequest":"/home/vikky/SportSocialWebsite/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/vikky/SportSocialWebsite/node_modules/@firebase/app/dist/index.cjs.js","dependencies":[{"path":"/home/vikky/SportSocialWebsite/node_modules/@firebase/app/dist/index.cjs.js","mtime":1558958972277},{"path":"/home/vikky/SportSocialWebsite/node_modules/cache-loader/dist/cjs.js","mtime":1558602431581},{"path":"/home/vikky/SportSocialWebsite/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1558602427806}],"contextDependencies":[],"result":["'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar tslib_1 = require('tslib');\nvar util = require('@firebase/util');\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\nvar ERRORS = (_a = {},\n    _a[\"no-app\" /* NO_APP */] = \"No Firebase App '{$name}' has been created - \" +\n        'call Firebase App.initializeApp()',\n    _a[\"bad-app-name\" /* BAD_APP_NAME */] = \"Illegal App name: '{$name}\",\n    _a[\"duplicate-app\" /* DUPLICATE_APP */] = \"Firebase App named '{$name}' already exists\",\n    _a[\"app-deleted\" /* APP_DELETED */] = \"Firebase App named '{$name}' already deleted\",\n    _a[\"duplicate-service\" /* DUPLICATE_SERVICE */] = \"Firebase service named '{$name}' already registered\",\n    _a[\"invalid-app-argument\" /* INVALID_APP_ARGUMENT */] = 'firebase.{$name}() takes either no argument or a ' +\n        'Firebase App instance.',\n    _a);\nvar appErrors = new util.ErrorFactory('app', 'Firebase', ERRORS);\nfunction error(code, args) {\n    throw appErrors.create(code, args);\n}\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// An array to capture listeners before the true auth functions\n// exist\nvar tokenListeners = [];\n/**\n * Global context object for a collection of services using\n * a shared authentication state.\n */\nvar FirebaseAppImpl = /** @class */ /*@__PURE__*/ (function () {\n    function FirebaseAppImpl(options, config, firebase_) {\n        this.firebase_ = firebase_;\n        this.isDeleted_ = false;\n        this.services_ = {};\n        this.name_ = config.name;\n        this.automaticDataCollectionEnabled_ =\n            config.automaticDataCollectionEnabled || false;\n        this.options_ = util.deepCopy(options);\n        this.INTERNAL = {\n            getUid: function () { return null; },\n            getToken: function () { return Promise.resolve(null); },\n            addAuthTokenListener: function (callback) {\n                tokenListeners.push(callback);\n                // Make sure callback is called, asynchronously, in the absence of the auth module\n                setTimeout(function () { return callback(null); }, 0);\n            },\n            removeAuthTokenListener: function (callback) {\n                tokenListeners = tokenListeners.filter(function (listener) { return listener !== callback; });\n            }\n        };\n    }\n    Object.defineProperty(FirebaseAppImpl.prototype, \"automaticDataCollectionEnabled\", {\n        get: function () {\n            this.checkDestroyed_();\n            return this.automaticDataCollectionEnabled_;\n        },\n        set: function (val) {\n            this.checkDestroyed_();\n            this.automaticDataCollectionEnabled_ = val;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseAppImpl.prototype, \"name\", {\n        get: function () {\n            this.checkDestroyed_();\n            return this.name_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(FirebaseAppImpl.prototype, \"options\", {\n        get: function () {\n            this.checkDestroyed_();\n            return this.options_;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    FirebaseAppImpl.prototype.delete = function () {\n        var _this = this;\n        return new Promise(function (resolve) {\n            _this.checkDestroyed_();\n            resolve();\n        })\n            .then(function () {\n            _this.firebase_.INTERNAL.removeApp(_this.name_);\n            var services = [];\n            for (var _i = 0, _a = Object.keys(_this.services_); _i < _a.length; _i++) {\n                var serviceKey = _a[_i];\n                for (var _b = 0, _c = Object.keys(_this.services_[serviceKey]); _b < _c.length; _b++) {\n                    var instanceKey = _c[_b];\n                    services.push(_this.services_[serviceKey][instanceKey]);\n                }\n            }\n            return Promise.all(services.map(function (service) {\n                return service.INTERNAL.delete();\n            }));\n        })\n            .then(function () {\n            _this.isDeleted_ = true;\n            _this.services_ = {};\n        });\n    };\n    /**\n     * Return a service instance associated with this app (creating it\n     * on demand), identified by the passed instanceIdentifier.\n     *\n     * NOTE: Currently storage is the only one that is leveraging this\n     * functionality. They invoke it by calling:\n     *\n     * ```javascript\n     * firebase.app().storage('STORAGE BUCKET ID')\n     * ```\n     *\n     * The service name is passed to this already\n     * @internal\n     */\n    FirebaseAppImpl.prototype._getService = function (name, instanceIdentifier) {\n        if (instanceIdentifier === void 0) {\n            instanceIdentifier = DEFAULT_ENTRY_NAME;\n        }\n        this.checkDestroyed_();\n        if (!this.services_[name]) {\n            this.services_[name] = {};\n        }\n        if (!this.services_[name][instanceIdentifier]) {\n            /**\n             * If a custom instance has been defined (i.e. not '[DEFAULT]')\n             * then we will pass that instance on, otherwise we pass `null`\n             */\n            var instanceSpecifier = instanceIdentifier !== DEFAULT_ENTRY_NAME\n                ? instanceIdentifier\n                : undefined;\n            var service = this.firebase_.INTERNAL.factories[name](this, this.extendApp.bind(this), instanceSpecifier);\n            this.services_[name][instanceIdentifier] = service;\n        }\n        return this.services_[name][instanceIdentifier];\n    };\n    /**\n     * Callback function used to extend an App instance at the time\n     * of service instance creation.\n     */\n    FirebaseAppImpl.prototype.extendApp = function (props) {\n        var _this = this;\n        // Copy the object onto the FirebaseAppImpl prototype\n        util.deepExtend(this, props);\n        /**\n         * If the app has overwritten the addAuthTokenListener stub, forward\n         * the active token listeners on to the true fxn.\n         *\n         * TODO: This function is required due to our current module\n         * structure. Once we are able to rely strictly upon a single module\n         * implementation, this code should be refactored and Auth should\n         * provide these stubs and the upgrade logic\n         */\n        if (props.INTERNAL && props.INTERNAL.addAuthTokenListener) {\n            tokenListeners.forEach(function (listener) {\n                _this.INTERNAL.addAuthTokenListener(listener);\n            });\n            tokenListeners = [];\n        }\n    };\n    /**\n     * This function will throw an Error if the App has already been deleted -\n     * use before performing API actions on the App.\n     */\n    FirebaseAppImpl.prototype.checkDestroyed_ = function () {\n        if (this.isDeleted_) {\n            error(\"app-deleted\" /* APP_DELETED */, { name: this.name_ });\n        }\n    };\n    return FirebaseAppImpl;\n}());\n// Prevent dead-code elimination of these methods w/o invalid property\n// copying.\n(FirebaseAppImpl.prototype.name && FirebaseAppImpl.prototype.options) ||\n    FirebaseAppImpl.prototype.delete ||\n    console.log('dc');\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction contains(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n/**\n * Because auth can't share code with other components, we attach the utility functions\n * in an internal namespace to share code.\n * This function return a firebase namespace object without\n * any utility functions, so it can be shared between the regular firebaseNamespace and\n * the lite version.\n */\nfunction createFirebaseNamespaceCore(firebaseAppImpl) {\n    var apps = {};\n    var factories = {};\n    var appHooks = {};\n    // A namespace is a plain JavaScript Object.\n    var namespace = {\n        // Hack to prevent Babel from modifying the object returned\n        // as the firebase namespace.\n        // @ts-ignore\n        __esModule: true,\n        initializeApp: initializeApp,\n        app: app,\n        apps: null,\n        Promise: Promise,\n        SDK_VERSION: '5.11.0',\n        INTERNAL: {\n            registerService: registerService,\n            removeApp: removeApp,\n            factories: factories,\n            useAsService: useAsService\n        }\n    };\n    // Inject a circular default export to allow Babel users who were previously\n    // using:\n    //\n    //   import firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase').default;\n    //\n    // instead of\n    //\n    //   import * as firebase from 'firebase';\n    //   which becomes: var firebase = require('firebase');\n    util.patchProperty(namespace, 'default', namespace);\n    // firebase.apps is a read-only getter.\n    Object.defineProperty(namespace, 'apps', {\n        get: getApps\n    });\n    /**\n     * Called by App.delete() - but before any services associated with the App\n     * are deleted.\n     */\n    function removeApp(name) {\n        var app = apps[name];\n        callAppHooks(app, 'delete');\n        delete apps[name];\n    }\n    /**\n     * Get the App object for a given name (or DEFAULT).\n     */\n    function app(name) {\n        name = name || DEFAULT_ENTRY_NAME;\n        if (!contains(apps, name)) {\n            error(\"no-app\" /* NO_APP */, { name: name });\n        }\n        return apps[name];\n    }\n    util.patchProperty(app, 'App', firebaseAppImpl);\n    function initializeApp(options, rawConfig) {\n        if (rawConfig === void 0) {\n            rawConfig = {};\n        }\n        if (typeof rawConfig !== 'object' || rawConfig === null) {\n            var name_1 = rawConfig;\n            rawConfig = { name: name_1 };\n        }\n        var config = rawConfig;\n        if (config.name === undefined) {\n            config.name = DEFAULT_ENTRY_NAME;\n        }\n        var name = config.name;\n        if (typeof name !== 'string' || !name) {\n            error(\"bad-app-name\" /* BAD_APP_NAME */, { name: String(name) });\n        }\n        if (contains(apps, name)) {\n            error(\"duplicate-app\" /* DUPLICATE_APP */, { name: name });\n        }\n        var app = new firebaseAppImpl(options, config, namespace);\n        apps[name] = app;\n        callAppHooks(app, 'create');\n        return app;\n    }\n    /*\n     * Return an array of all the non-deleted FirebaseApps.\n     */\n    function getApps() {\n        // Make a copy so caller cannot mutate the apps list.\n        return Object.keys(apps).map(function (name) { return apps[name]; });\n    }\n    /*\n     * Register a Firebase Service.\n     *\n     * firebase.INTERNAL.registerService()\n     *\n     * TODO: Implement serviceProperties.\n     */\n    function registerService(name, createService, serviceProperties, appHook, allowMultipleInstances) {\n        if (allowMultipleInstances === void 0) {\n            allowMultipleInstances = false;\n        }\n        // Cannot re-register a service that already exists\n        if (factories[name]) {\n            error(\"duplicate-service\" /* DUPLICATE_SERVICE */, { name: name });\n        }\n        // Capture the service factory for later service instantiation\n        factories[name] = createService;\n        // Capture the appHook, if passed\n        if (appHook) {\n            appHooks[name] = appHook;\n            // Run the **new** app hook on all existing apps\n            getApps().forEach(function (app) {\n                appHook('create', app);\n            });\n        }\n        // The Service namespace is an accessor function ...\n        function serviceNamespace(appArg) {\n            if (appArg === void 0) {\n                appArg = app();\n            }\n            if (typeof appArg[name] !== 'function') {\n                // Invalid argument.\n                // This happens in the following case: firebase.storage('gs:/')\n                error(\"invalid-app-argument\" /* INVALID_APP_ARGUMENT */, { name: name });\n            }\n            // Forward service instance lookup to the FirebaseApp.\n            return appArg[name]();\n        }\n        // ... and a container for service-level properties.\n        if (serviceProperties !== undefined) {\n            util.deepExtend(serviceNamespace, serviceProperties);\n        }\n        // Monkey-patch the serviceNamespace onto the firebase namespace\n        namespace[name] = serviceNamespace;\n        // Patch the FirebaseAppImpl prototype\n        firebaseAppImpl.prototype[name] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var serviceFxn = this._getService.bind(this, name);\n            return serviceFxn.apply(this, allowMultipleInstances ? args : []);\n        };\n        return serviceNamespace;\n    }\n    function callAppHooks(app, eventName) {\n        for (var _i = 0, _a = Object.keys(factories); _i < _a.length; _i++) {\n            var serviceName = _a[_i];\n            // Ignore virtual services\n            var factoryName = useAsService(app, serviceName);\n            if (factoryName === null) {\n                return;\n            }\n            if (appHooks[factoryName]) {\n                appHooks[factoryName](eventName, app);\n            }\n        }\n    }\n    // Map the requested service to a registered service name\n    // (used to map auth to serverAuth service when needed).\n    function useAsService(app, name) {\n        if (name === 'serverAuth') {\n            return null;\n        }\n        var useService = name;\n        var options = app.options;\n        return useService;\n    }\n    return namespace;\n}\n/**\n * @license\n * Copyright 2019 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Return a firebase namespace object.\n *\n * In production, this will be called exactly once and the result\n * assigned to the 'firebase' global.  It may be called multiple times\n * in unit tests.\n */\nfunction createFirebaseNamespace() {\n    var namespace = createFirebaseNamespaceCore(FirebaseAppImpl);\n    namespace.INTERNAL = tslib_1.__assign({}, namespace.INTERNAL, { createFirebaseNamespace: createFirebaseNamespace, extendNamespace: extendNamespace, createSubscribe: util.createSubscribe, ErrorFactory: util.ErrorFactory, deepExtend: util.deepExtend });\n    /**\n     * Patch the top-level firebase namespace with additional properties.\n     *\n     * firebase.INTERNAL.extendNamespace()\n     */\n    function extendNamespace(props) {\n        util.deepExtend(namespace, props);\n    }\n    return namespace;\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n// Node detection logic from: https://github.com/iliakan/detect-node/\nvar isNode = false;\ntry {\n    isNode =\n        Object.prototype.toString.call(global.process) === '[object process]';\n}\ncatch (e) { }\nisNode &&\n    console.warn(\"\\nWarning: This is a browser-targeted Firebase bundle but it appears it is being\\nrun in a Node environment.  If running in a Node environment, make sure you\\nare using the bundle specified by the \\\"main\\\" field in package.json.\\n\\nIf you are using Webpack, you can specify \\\"main\\\" as the first item in\\n\\\"resolve.mainFields\\\":\\nhttps://webpack.js.org/configuration/resolve/#resolvemainfields\\n\\nIf using Rollup, use the rollup-plugin-node-resolve plugin and set \\\"module\\\"\\nto false and \\\"main\\\" to true:\\nhttps://github.com/rollup/rollup-plugin-node-resolve\\n\");\n// Firebase Lite detection\nif (self && 'firebase' in self) {\n    console.warn(\"\\n    Warning: Firebase is already defined in the global scope. Please make sure\\n    Firebase library is only loaded once.\\n  \");\n    var sdkVersion = self.firebase.SDK_VERSION;\n    if (sdkVersion && sdkVersion.indexOf('LITE') >= 0) {\n        console.warn(\"\\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\\n    \");\n    }\n}\nvar firebase = createFirebaseNamespace();\nexports.default = firebase;\nexports.firebase = firebase;\n",null]}