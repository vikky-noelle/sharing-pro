{"remainingRequest":"/Users/sportssocialweb/Desktop/SportSocialWebsite/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/Users/sportssocialweb/Desktop/SportSocialWebsite/node_modules/@firebase/messaging/dist/index.esm.js","dependencies":[{"path":"/Users/sportssocialweb/Desktop/SportSocialWebsite/node_modules/@firebase/messaging/dist/index.esm.js","mtime":1557405505749},{"path":"/Users/sportssocialweb/Desktop/SportSocialWebsite/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/sportssocialweb/Desktop/SportSocialWebsite/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1535052364000}],"contextDependencies":[],"result":["import firebase from '@firebase/app';\nimport { __spread, __awaiter, __generator, __extends, __assign } from 'tslib';\nimport { ErrorFactory, createSubscribe } from '@firebase/util';\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar _a;\nvar ERROR_MAP = (_a = {},\n    _a[\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */] = 'This method is available in a Window context.',\n    _a[\"only-available-in-sw\" /* AVAILABLE_IN_SW */] = 'This method is available in a service worker ' + 'context.',\n    _a[\"should-be-overriden\" /* SHOULD_BE_INHERITED */] = 'This method should be overriden by ' + 'extended classes.',\n    _a[\"bad-sender-id\" /* BAD_SENDER_ID */] = \"Please ensure that 'messagingSenderId' is set \" +\n        'correctly in the options passed into firebase.initializeApp().',\n    _a[\"permission-default\" /* PERMISSION_DEFAULT */] = 'The required permissions were not granted and ' + 'dismissed instead.',\n    _a[\"permission-blocked\" /* PERMISSION_BLOCKED */] = 'The required permissions were not granted and ' + 'blocked instead.',\n    _a[\"unsupported-browser\" /* UNSUPPORTED_BROWSER */] = \"This browser doesn't support the API's \" +\n        'required to use the firebase SDK.',\n    _a[\"notifications-blocked\" /* NOTIFICATIONS_BLOCKED */] = 'Notifications have been blocked.',\n    _a[\"failed-serviceworker-registration\" /* FAILED_DEFAULT_REGISTRATION */] = 'We are unable to register the ' +\n        'default service worker. {$browserErrorMessage}',\n    _a[\"sw-registration-expected\" /* SW_REGISTRATION_EXPECTED */] = 'A service worker registration was the ' + 'expected input.',\n    _a[\"get-subscription-failed\" /* GET_SUBSCRIPTION_FAILED */] = 'There was an error when trying to get ' +\n        'any existing Push Subscriptions.',\n    _a[\"invalid-saved-token\" /* INVALID_SAVED_TOKEN */] = 'Unable to access details of the saved token.',\n    _a[\"sw-reg-redundant\" /* SW_REG_REDUNDANT */] = 'The service worker being used for push was made ' + 'redundant.',\n    _a[\"token-subscribe-failed\" /* TOKEN_SUBSCRIBE_FAILED */] = 'A problem occured while subscribing the ' + 'user to FCM: {$message}',\n    _a[\"token-subscribe-no-token\" /* TOKEN_SUBSCRIBE_NO_TOKEN */] = 'FCM returned no token when subscribing ' + 'the user to push.',\n    _a[\"token-subscribe-no-push-set\" /* TOKEN_SUBSCRIBE_NO_PUSH_SET */] = 'FCM returned an invalid response ' + 'when getting an FCM token.',\n    _a[\"token-unsubscribe-failed\" /* TOKEN_UNSUBSCRIBE_FAILED */] = 'A problem occured while unsubscribing the ' + 'user from FCM: {$message}',\n    _a[\"token-update-failed\" /* TOKEN_UPDATE_FAILED */] = 'A problem occured while updating the ' + 'user from FCM: {$message}',\n    _a[\"token-update-no-token\" /* TOKEN_UPDATE_NO_TOKEN */] = 'FCM returned no token when updating ' + 'the user to push.',\n    _a[\"use-sw-before-get-token\" /* USE_SW_BEFORE_GET_TOKEN */] = 'The useServiceWorker() method may only be called once and must be ' +\n        'called before calling getToken() to ensure your service worker is used.',\n    _a[\"invalid-delete-token\" /* INVALID_DELETE_TOKEN */] = 'You must pass a valid token into ' +\n        'deleteToken(), i.e. the token from getToken().',\n    _a[\"delete-token-not-found\" /* DELETE_TOKEN_NOT_FOUND */] = 'The deletion attempt for token could not ' +\n        'be performed as the token was not found.',\n    _a[\"delete-scope-not-found\" /* DELETE_SCOPE_NOT_FOUND */] = 'The deletion attempt for service worker ' +\n        'scope could not be performed as the scope was not found.',\n    _a[\"bg-handler-function-expected\" /* BG_HANDLER_FUNCTION_EXPECTED */] = 'The input to ' + 'setBackgroundMessageHandler() must be a function.',\n    _a[\"no-window-client-to-msg\" /* NO_WINDOW_CLIENT_TO_MSG */] = 'An attempt was made to message a ' + 'non-existant window client.',\n    _a[\"unable-to-resubscribe\" /* UNABLE_TO_RESUBSCRIBE */] = 'There was an error while re-subscribing ' +\n        'the FCM token for push messaging. Will have to resubscribe the ' +\n        'user on next visit. {$message}',\n    _a[\"no-fcm-token-for-resubscribe\" /* NO_FCM_TOKEN_FOR_RESUBSCRIBE */] = 'Could not find an FCM token ' +\n        'and as a result, unable to resubscribe. Will have to resubscribe the ' +\n        'user on next visit.',\n    _a[\"failed-to-delete-token\" /* FAILED_TO_DELETE_TOKEN */] = 'Unable to delete the currently saved token.',\n    _a[\"no-sw-in-reg\" /* NO_SW_IN_REG */] = 'Even though the service worker registration was ' +\n        'successful, there was a problem accessing the service worker itself.',\n    _a[\"incorrect-gcm-sender-id\" /* INCORRECT_GCM_SENDER_ID */] = \"Please change your web app manifest's \" +\n        \"'gcm_sender_id' value to '103953800507' to use Firebase messaging.\",\n    _a[\"bad-scope\" /* BAD_SCOPE */] = 'The service worker scope must be a string with at ' +\n        'least one character.',\n    _a[\"bad-vapid-key\" /* BAD_VAPID_KEY */] = 'The public VAPID key is not a Uint8Array with 65 bytes.',\n    _a[\"bad-subscription\" /* BAD_SUBSCRIPTION */] = 'The subscription must be a valid ' + 'PushSubscription.',\n    _a[\"bad-token\" /* BAD_TOKEN */] = 'The FCM Token used for storage / lookup was not ' +\n        'a valid token string.',\n    _a[\"bad-push-set\" /* BAD_PUSH_SET */] = 'The FCM push set used for storage / lookup was not ' +\n        'not a valid push set string.',\n    _a[\"failed-delete-vapid-key\" /* FAILED_DELETE_VAPID_KEY */] = 'The VAPID key could not be deleted.',\n    _a[\"invalid-public-vapid-key\" /* INVALID_PUBLIC_VAPID_KEY */] = 'The public VAPID key must be a string.',\n    _a[\"use-public-key-before-get-token\" /* USE_PUBLIC_KEY_BEFORE_GET_TOKEN */] = 'The usePublicVapidKey() method may only be called once and must be ' +\n        'called before calling getToken() to ensure your VAPID key is used.',\n    _a[\"public-vapid-key-decryption-failed\" /* PUBLIC_KEY_DECRYPTION_FAILED */] = 'The public VAPID key did not equal ' + '65 bytes when decrypted.',\n    _a);\nvar errorFactory = new ErrorFactory('messaging', 'Messaging', ERROR_MAP);\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_PUBLIC_VAPID_KEY = new Uint8Array([\n    0x04,\n    0x33,\n    0x94,\n    0xf7,\n    0xdf,\n    0xa1,\n    0xeb,\n    0xb1,\n    0xdc,\n    0x03,\n    0xa2,\n    0x5e,\n    0x15,\n    0x71,\n    0xdb,\n    0x48,\n    0xd3,\n    0x2e,\n    0xed,\n    0xed,\n    0xb2,\n    0x34,\n    0xdb,\n    0xb7,\n    0x47,\n    0x3a,\n    0x0c,\n    0x8f,\n    0xc4,\n    0xcc,\n    0xe1,\n    0x6f,\n    0x3c,\n    0x8c,\n    0x84,\n    0xdf,\n    0xab,\n    0xb6,\n    0x66,\n    0x3e,\n    0xf2,\n    0x0c,\n    0xd4,\n    0x8b,\n    0xfe,\n    0xe3,\n    0xf9,\n    0x76,\n    0x2f,\n    0x14,\n    0x1c,\n    0x63,\n    0x08,\n    0x6a,\n    0x6f,\n    0x2d,\n    0xb1,\n    0x1a,\n    0x95,\n    0xb0,\n    0xce,\n    0x37,\n    0xc0,\n    0x9c,\n    0x6e\n]);\nvar ENDPOINT = 'https://fcm.googleapis.com';\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar MessageParameter;\n(function (MessageParameter) {\n    MessageParameter[\"TYPE_OF_MSG\"] = \"firebase-messaging-msg-type\";\n    MessageParameter[\"DATA\"] = \"firebase-messaging-msg-data\";\n})(MessageParameter || (MessageParameter = {}));\nvar MessageType;\n(function (MessageType) {\n    MessageType[\"PUSH_MSG_RECEIVED\"] = \"push-msg-received\";\n    MessageType[\"NOTIFICATION_CLICKED\"] = \"notification-clicked\";\n})(MessageType || (MessageType = {}));\n/**\n * @license\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction isArrayBufferEqual(a, b) {\n    if (a == null || b == null) {\n        return false;\n    }\n    if (a === b) {\n        return true;\n    }\n    if (a.byteLength !== b.byteLength) {\n        return false;\n    }\n    var viewA = new DataView(a);\n    var viewB = new DataView(b);\n    for (var i = 0; i < a.byteLength; i++) {\n        if (viewA.getUint8(i) !== viewB.getUint8(i)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction toBase64(arrayBuffer) {\n    var uint8Version = new Uint8Array(arrayBuffer);\n    return btoa(String.fromCharCode.apply(String, __spread(uint8Version)));\n}\nfunction arrayBufferToBase64(arrayBuffer) {\n    var base64String = toBase64(arrayBuffer);\n    return base64String\n        .replace(/=/g, '')\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_');\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar IidModel = /** @class */ /*@__PURE__*/ (function () {\n    function IidModel() {\n    }\n    IidModel.prototype.getToken = function (senderId, subscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var p256dh, auth, fcmSubscribeBody, applicationPubKey, headers, subscribeOptions, responseData, response, err_1, message;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        p256dh = arrayBufferToBase64(subscription.getKey('p256dh'));\n                        auth = arrayBufferToBase64(subscription.getKey('auth'));\n                        fcmSubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n                            (\"endpoint=\" + subscription.endpoint + \"&\") +\n                            (\"encryption_key=\" + p256dh + \"&\") +\n                            (\"encryption_auth=\" + auth);\n                        if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n                            applicationPubKey = arrayBufferToBase64(publicVapidKey);\n                            fcmSubscribeBody += \"&application_pub_key=\" + applicationPubKey;\n                        }\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        subscribeOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmSubscribeBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/subscribe', subscribeOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_1 = _a.sent();\n                        throw errorFactory.create(\"token-subscribe-failed\" /* TOKEN_SUBSCRIBE_FAILED */);\n                    case 5:\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(\"token-subscribe-failed\" /* TOKEN_SUBSCRIBE_FAILED */, {\n                                message: message\n                            });\n                        }\n                        if (!responseData.token) {\n                            throw errorFactory.create(\"token-subscribe-no-token\" /* TOKEN_SUBSCRIBE_NO_TOKEN */);\n                        }\n                        if (!responseData.pushSet) {\n                            throw errorFactory.create(\"token-subscribe-no-push-set\" /* TOKEN_SUBSCRIBE_NO_PUSH_SET */);\n                        }\n                        return [2 /*return*/, {\n                                token: responseData.token,\n                                pushSet: responseData.pushSet\n                            }];\n                }\n            });\n        });\n    };\n    /**\n     * Update the underlying token details for fcmToken.\n     */\n    IidModel.prototype.updateToken = function (senderId, fcmToken, fcmPushSet, subscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var p256dh, auth, fcmUpdateBody, applicationPubKey, headers, updateOptions, responseData, response, err_2, message;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        p256dh = arrayBufferToBase64(subscription.getKey('p256dh'));\n                        auth = arrayBufferToBase64(subscription.getKey('auth'));\n                        fcmUpdateBody = \"push_set=\" + fcmPushSet + \"&\" +\n                            (\"token=\" + fcmToken + \"&\") +\n                            (\"authorized_entity=\" + senderId + \"&\") +\n                            (\"endpoint=\" + subscription.endpoint + \"&\") +\n                            (\"encryption_key=\" + p256dh + \"&\") +\n                            (\"encryption_auth=\" + auth);\n                        if (!isArrayBufferEqual(publicVapidKey.buffer, DEFAULT_PUBLIC_VAPID_KEY.buffer)) {\n                            applicationPubKey = arrayBufferToBase64(publicVapidKey);\n                            fcmUpdateBody += \"&application_pub_key=\" + applicationPubKey;\n                        }\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        updateOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmUpdateBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/subscribe', updateOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_2 = _a.sent();\n                        throw errorFactory.create(\"token-update-failed\" /* TOKEN_UPDATE_FAILED */);\n                    case 5:\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(\"token-update-failed\" /* TOKEN_UPDATE_FAILED */, {\n                                message: message\n                            });\n                        }\n                        if (!responseData.token) {\n                            throw errorFactory.create(\"token-update-no-token\" /* TOKEN_UPDATE_NO_TOKEN */);\n                        }\n                        return [2 /*return*/, responseData.token];\n                }\n            });\n        });\n    };\n    /**\n     * Given a fcmToken, pushSet and messagingSenderId, delete an FCM token.\n     */\n    IidModel.prototype.deleteToken = function (senderId, fcmToken, fcmPushSet) {\n        return __awaiter(this, void 0, void 0, function () {\n            var fcmUnsubscribeBody, headers, unsubscribeOptions, response, responseData, message, err_3;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        fcmUnsubscribeBody = \"authorized_entity=\" + senderId + \"&\" +\n                            (\"token=\" + fcmToken + \"&\") +\n                            (\"pushSet=\" + fcmPushSet);\n                        headers = new Headers();\n                        headers.append('Content-Type', 'application/x-www-form-urlencoded');\n                        unsubscribeOptions = {\n                            method: 'POST',\n                            headers: headers,\n                            body: fcmUnsubscribeBody\n                        };\n                        _a.label = 1;\n                    case 1:\n                        _a.trys.push([1, 4, , 5]);\n                        return [4 /*yield*/, fetch(ENDPOINT + '/fcm/connect/unsubscribe', unsubscribeOptions)];\n                    case 2:\n                        response = _a.sent();\n                        return [4 /*yield*/, response.json()];\n                    case 3:\n                        responseData = _a.sent();\n                        if (responseData.error) {\n                            message = responseData.error.message;\n                            throw errorFactory.create(\"token-unsubscribe-failed\" /* TOKEN_UNSUBSCRIBE_FAILED */, {\n                                message: message\n                            });\n                        }\n                        return [3 /*break*/, 5];\n                    case 4:\n                        err_3 = _a.sent();\n                        throw errorFactory.create(\"token-unsubscribe-failed\" /* TOKEN_UNSUBSCRIBE_FAILED */);\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    return IidModel;\n}());\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction base64ToArrayBuffer(base64String) {\n    var padding = '='.repeat((4 - (base64String.length % 4)) % 4);\n    var base64 = (base64String + padding)\n        .replace(/\\-/g, '+')\n        .replace(/_/g, '/');\n    var rawData = atob(base64);\n    var outputArray = new Uint8Array(rawData.length);\n    for (var i = 0; i < rawData.length; ++i) {\n        outputArray[i] = rawData.charCodeAt(i);\n    }\n    return outputArray;\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar OLD_DB_NAME = 'undefined';\nvar OLD_OBJECT_STORE_NAME = 'fcm_token_object_Store';\nfunction handleDb(db) {\n    if (!db.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {\n        // We found a database with the name 'undefined', but our expected object\n        // store isn't defined.\n        return;\n    }\n    var transaction = db.transaction(OLD_OBJECT_STORE_NAME);\n    var objectStore = transaction.objectStore(OLD_OBJECT_STORE_NAME);\n    var iidModel = new IidModel();\n    var openCursorRequest = objectStore.openCursor();\n    openCursorRequest.onerror = function (event) {\n        // NOOP - Nothing we can do.\n        console.warn('Unable to cleanup old IDB.', event);\n    };\n    openCursorRequest.onsuccess = function () {\n        var cursor = openCursorRequest.result;\n        if (cursor) {\n            // cursor.value contains the current record being iterated through\n            // this is where you'd do something with the result\n            var tokenDetails = cursor.value;\n            iidModel.deleteToken(tokenDetails.fcmSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet);\n            cursor.continue();\n        }\n        else {\n            db.close();\n            indexedDB.deleteDatabase(OLD_DB_NAME);\n        }\n    };\n}\nfunction cleanV1() {\n    var request = indexedDB.open(OLD_DB_NAME);\n    request.onerror = function (event) {\n        // NOOP - Nothing we can do.\n    };\n    request.onsuccess = function (event) {\n        var db = request.result;\n        handleDb(db);\n    };\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DbInterface = /** @class */ /*@__PURE__*/ (function () {\n    function DbInterface() {\n        this.dbPromise = null;\n    }\n    /** Gets record(s) from the objectStore that match the given key. */\n    DbInterface.prototype.get = function (key) {\n        return this.createTransaction(function (objectStore) { return objectStore.get(key); });\n    };\n    /** Gets record(s) from the objectStore that match the given index. */\n    DbInterface.prototype.getIndex = function (index, key) {\n        function runRequest(objectStore) {\n            var idbIndex = objectStore.index(index);\n            return idbIndex.get(key);\n        }\n        return this.createTransaction(runRequest);\n    };\n    /** Assigns or overwrites the record for the given value. */\n    // tslint:disable-next-line:no-any IndexedDB values are of type \"any\"\n    DbInterface.prototype.put = function (value) {\n        return this.createTransaction(function (objectStore) { return objectStore.put(value); }, 'readwrite');\n    };\n    /** Deletes record(s) from the objectStore that match the given key. */\n    DbInterface.prototype.delete = function (key) {\n        return this.createTransaction(function (objectStore) { return objectStore.delete(key); }, 'readwrite');\n    };\n    /**\n     * Close the currently open database.\n     */\n    DbInterface.prototype.closeDatabase = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var db;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.dbPromise)\n                            return [3 /*break*/, 2];\n                        return [4 /*yield*/, this.dbPromise];\n                    case 1:\n                        db = _a.sent();\n                        db.close();\n                        this.dbPromise = null;\n                        _a.label = 2;\n                    case 2: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Creates an IndexedDB Transaction and passes its objectStore to the\n     * runRequest function, which runs the database request.\n     *\n     * @return Promise that resolves with the result of the runRequest function\n     */\n    DbInterface.prototype.createTransaction = function (runRequest, mode) {\n        if (mode === void 0) {\n            mode = 'readonly';\n        }\n        return __awaiter(this, void 0, void 0, function () {\n            var db, transaction, request, result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getDb()];\n                    case 1:\n                        db = _a.sent();\n                        transaction = db.transaction(this.objectStoreName, mode);\n                        request = transaction.objectStore(this.objectStoreName);\n                        return [4 /*yield*/, promisify(runRequest(request))];\n                    case 2:\n                        result = _a.sent();\n                        return [2 /*return*/, new Promise(function (resolve, reject) {\n                                transaction.oncomplete = function () {\n                                    resolve(result);\n                                };\n                                transaction.onerror = function () {\n                                    reject(transaction.error);\n                                };\n                            })];\n                }\n            });\n        });\n    };\n    /** Gets the cached db connection or opens a new one. */\n    DbInterface.prototype.getDb = function () {\n        var _this = this;\n        if (!this.dbPromise) {\n            this.dbPromise = new Promise(function (resolve, reject) {\n                var request = indexedDB.open(_this.dbName, _this.dbVersion);\n                request.onsuccess = function () {\n                    resolve(request.result);\n                };\n                request.onerror = function () {\n                    _this.dbPromise = null;\n                    reject(request.error);\n                };\n                request.onupgradeneeded = function (event) { return _this.onDbUpgrade(request, event); };\n            });\n        }\n        return this.dbPromise;\n    };\n    return DbInterface;\n}());\n/** Promisifies an IDBRequest. Resolves with the IDBRequest's result. */\nfunction promisify(request) {\n    return new Promise(function (resolve, reject) {\n        request.onsuccess = function () {\n            resolve(request.result);\n        };\n        request.onerror = function () {\n            reject(request.error);\n        };\n    });\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar TokenDetailsModel = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(TokenDetailsModel, _super);\n    function TokenDetailsModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dbName = 'fcm_token_details_db';\n        _this.dbVersion = 3;\n        _this.objectStoreName = 'fcm_token_object_Store';\n        return _this;\n    }\n    TokenDetailsModel.prototype.onDbUpgrade = function (request, event) {\n        var db = request.result;\n        // Lack of 'break' statements is intentional.\n        switch (event.oldVersion) {\n            case 0: {\n                // New IDB instance\n                var objectStore = db.createObjectStore(this.objectStoreName, {\n                    keyPath: 'swScope'\n                });\n                // Make sure the sender ID can be searched\n                objectStore.createIndex('fcmSenderId', 'fcmSenderId', {\n                    unique: false\n                });\n                objectStore.createIndex('fcmToken', 'fcmToken', { unique: true });\n            }\n            case 1: {\n                // Prior to version 2, we were using either 'fcm_token_details_db'\n                // or 'undefined' as the database name due to bug in the SDK\n                // So remove the old tokens and databases.\n                cleanV1();\n            }\n            case 2: {\n                var objectStore = request.transaction.objectStore(this.objectStoreName);\n                var cursorRequest_1 = objectStore.openCursor();\n                cursorRequest_1.onsuccess = function () {\n                    var cursor = cursorRequest_1.result;\n                    if (cursor) {\n                        var value = cursor.value;\n                        var newValue = __assign({}, value);\n                        if (!value.createTime) {\n                            newValue.createTime = Date.now();\n                        }\n                        if (typeof value.vapidKey === 'string') {\n                            newValue.vapidKey = base64ToArrayBuffer(value.vapidKey);\n                        }\n                        if (typeof value.auth === 'string') {\n                            newValue.auth = base64ToArrayBuffer(value.auth).buffer;\n                        }\n                        if (typeof value.auth === 'string') {\n                            newValue.p256dh = base64ToArrayBuffer(value.p256dh).buffer;\n                        }\n                        cursor.update(newValue);\n                        cursor.continue();\n                    }\n                };\n            }\n        }\n    };\n    /**\n     * Given a token, this method will look up the details in indexedDB.\n     */\n    TokenDetailsModel.prototype.getTokenDetailsFromToken = function (fcmToken) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!fcmToken) {\n                    throw errorFactory.create(\"bad-token\" /* BAD_TOKEN */);\n                }\n                validateInputs({ fcmToken: fcmToken });\n                return [2 /*return*/, this.getIndex('fcmToken', fcmToken)];\n            });\n        });\n    };\n    /**\n     * Given a service worker scope, this method will look up the details in\n     * indexedDB.\n     * @return The details associated with that token.\n     */\n    TokenDetailsModel.prototype.getTokenDetailsFromSWScope = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!swScope) {\n                    throw errorFactory.create(\"bad-scope\" /* BAD_SCOPE */);\n                }\n                validateInputs({ swScope: swScope });\n                return [2 /*return*/, this.get(swScope)];\n            });\n        });\n    };\n    /**\n     * Save the details for the fcm token for re-use at a later date.\n     * @param input A plain js object containing args to save.\n     */\n    TokenDetailsModel.prototype.saveTokenDetails = function (tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (!tokenDetails.swScope) {\n                    throw errorFactory.create(\"bad-scope\" /* BAD_SCOPE */);\n                }\n                if (!tokenDetails.vapidKey) {\n                    throw errorFactory.create(\"bad-vapid-key\" /* BAD_VAPID_KEY */);\n                }\n                if (!tokenDetails.endpoint || !tokenDetails.auth || !tokenDetails.p256dh) {\n                    throw errorFactory.create(\"bad-subscription\" /* BAD_SUBSCRIPTION */);\n                }\n                if (!tokenDetails.fcmSenderId) {\n                    throw errorFactory.create(\"bad-sender-id\" /* BAD_SENDER_ID */);\n                }\n                if (!tokenDetails.fcmToken) {\n                    throw errorFactory.create(\"bad-token\" /* BAD_TOKEN */);\n                }\n                if (!tokenDetails.fcmPushSet) {\n                    throw errorFactory.create(\"bad-push-set\" /* BAD_PUSH_SET */);\n                }\n                validateInputs(tokenDetails);\n                return [2 /*return*/, this.put(tokenDetails)];\n            });\n        });\n    };\n    /**\n     * This method deletes details of the current FCM token.\n     * It's returning a promise in case we need to move to an async\n     * method for deleting at a later date.\n     *\n     * @return Resolves once the FCM token details have been deleted and returns\n     * the deleted details.\n     */\n    TokenDetailsModel.prototype.deleteToken = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof token !== 'string' || token.length === 0) {\n                            return [2 /*return*/, Promise.reject(errorFactory.create(\"invalid-delete-token\" /* INVALID_DELETE_TOKEN */))];\n                        }\n                        return [4 /*yield*/, this.getTokenDetailsFromToken(token)];\n                    case 1:\n                        details = _a.sent();\n                        if (!details) {\n                            throw errorFactory.create(\"delete-token-not-found\" /* DELETE_TOKEN_NOT_FOUND */);\n                        }\n                        return [4 /*yield*/, this.delete(details.swScope)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, details];\n                }\n            });\n        });\n    };\n    return TokenDetailsModel;\n}(DbInterface));\n/**\n * This method takes an object and will check for known arguments and\n * validate the input.\n * @return Promise that resolves if input is valid, rejects otherwise.\n */\nfunction validateInputs(input) {\n    if (input.fcmToken) {\n        if (typeof input.fcmToken !== 'string' || input.fcmToken.length === 0) {\n            throw errorFactory.create(\"bad-token\" /* BAD_TOKEN */);\n        }\n    }\n    if (input.swScope) {\n        if (typeof input.swScope !== 'string' || input.swScope.length === 0) {\n            throw errorFactory.create(\"bad-scope\" /* BAD_SCOPE */);\n        }\n    }\n    if (input.vapidKey) {\n        if (!(input.vapidKey instanceof Uint8Array) ||\n            input.vapidKey.length !== 65) {\n            throw errorFactory.create(\"bad-vapid-key\" /* BAD_VAPID_KEY */);\n        }\n    }\n    if (input.endpoint) {\n        if (typeof input.endpoint !== 'string' || input.endpoint.length === 0) {\n            throw errorFactory.create(\"bad-subscription\" /* BAD_SUBSCRIPTION */);\n        }\n    }\n    if (input.auth) {\n        if (!(input.auth instanceof ArrayBuffer)) {\n            throw errorFactory.create(\"bad-subscription\" /* BAD_SUBSCRIPTION */);\n        }\n    }\n    if (input.p256dh) {\n        if (!(input.p256dh instanceof ArrayBuffer)) {\n            throw errorFactory.create(\"bad-subscription\" /* BAD_SUBSCRIPTION */);\n        }\n    }\n    if (input.fcmSenderId) {\n        if (typeof input.fcmSenderId !== 'string' ||\n            input.fcmSenderId.length === 0) {\n            throw errorFactory.create(\"bad-sender-id\" /* BAD_SENDER_ID */);\n        }\n    }\n    if (input.fcmPushSet) {\n        if (typeof input.fcmPushSet !== 'string' || input.fcmPushSet.length === 0) {\n            throw errorFactory.create(\"bad-push-set\" /* BAD_PUSH_SET */);\n        }\n    }\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar UNCOMPRESSED_PUBLIC_KEY_SIZE = 65;\nvar VapidDetailsModel = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(VapidDetailsModel, _super);\n    function VapidDetailsModel() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.dbName = 'fcm_vapid_details_db';\n        _this.dbVersion = 1;\n        _this.objectStoreName = 'fcm_vapid_object_Store';\n        return _this;\n    }\n    VapidDetailsModel.prototype.onDbUpgrade = function (request) {\n        var db = request.result;\n        db.createObjectStore(this.objectStoreName, { keyPath: 'swScope' });\n    };\n    /**\n     * Given a service worker scope, this method will look up the vapid key\n     * in indexedDB.\n     */\n    VapidDetailsModel.prototype.getVapidFromSWScope = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var result;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (typeof swScope !== 'string' || swScope.length === 0) {\n                            throw errorFactory.create(\"bad-scope\" /* BAD_SCOPE */);\n                        }\n                        return [4 /*yield*/, this.get(swScope)];\n                    case 1:\n                        result = _a.sent();\n                        return [2 /*return*/, result ? result.vapidKey : undefined];\n                }\n            });\n        });\n    };\n    /**\n     * Save a vapid key against a swScope for later date.\n     */\n    VapidDetailsModel.prototype.saveVapidDetails = function (swScope, vapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                if (typeof swScope !== 'string' || swScope.length === 0) {\n                    throw errorFactory.create(\"bad-scope\" /* BAD_SCOPE */);\n                }\n                if (vapidKey === null || vapidKey.length !== UNCOMPRESSED_PUBLIC_KEY_SIZE) {\n                    throw errorFactory.create(\"bad-vapid-key\" /* BAD_VAPID_KEY */);\n                }\n                details = {\n                    swScope: swScope,\n                    vapidKey: vapidKey\n                };\n                return [2 /*return*/, this.put(details)];\n            });\n        });\n    };\n    /**\n     * This method deletes details of the current FCM VAPID key for a SW scope.\n     * Resolves once the scope/vapid details have been deleted and returns the\n     * deleted vapid key.\n     */\n    VapidDetailsModel.prototype.deleteVapidDetails = function (swScope) {\n        return __awaiter(this, void 0, void 0, function () {\n            var vapidKey;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getVapidFromSWScope(swScope)];\n                    case 1:\n                        vapidKey = _a.sent();\n                        if (!vapidKey) {\n                            throw errorFactory.create(\"delete-scope-not-found\" /* DELETE_SCOPE_NOT_FOUND */);\n                        }\n                        return [4 /*yield*/, this.delete(swScope)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/, vapidKey];\n                }\n            });\n        });\n    };\n    return VapidDetailsModel;\n}(DbInterface));\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SENDER_ID_OPTION_NAME = 'messagingSenderId';\n// Database cache should be invalidated once a week.\nvar TOKEN_EXPIRATION_MILLIS = 7 * 24 * 60 * 60 * 1000; // 7 days\nvar BaseController = /** @class */ /*@__PURE__*/ (function () {\n    /**\n     * An interface of the Messaging Service API\n     */\n    function BaseController(app) {\n        var _this = this;\n        if (!app.options[SENDER_ID_OPTION_NAME] ||\n            typeof app.options[SENDER_ID_OPTION_NAME] !== 'string') {\n            throw errorFactory.create(\"bad-sender-id\" /* BAD_SENDER_ID */);\n        }\n        this.messagingSenderId = app.options[SENDER_ID_OPTION_NAME];\n        this.tokenDetailsModel = new TokenDetailsModel();\n        this.vapidDetailsModel = new VapidDetailsModel();\n        this.iidModel = new IidModel();\n        this.app = app;\n        this.INTERNAL = {\n            delete: function () { return _this.delete(); }\n        };\n    }\n    /**\n     * @export\n     */\n    BaseController.prototype.getToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var currentPermission, swReg, publicVapidKey, pushSubscription, tokenDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        currentPermission = this.getNotificationPermission_();\n                        if (currentPermission === 'denied') {\n                            throw errorFactory.create(\"notifications-blocked\" /* NOTIFICATIONS_BLOCKED */);\n                        }\n                        else if (currentPermission !== 'granted') {\n                            // We must wait for permission to be granted\n                            return [2 /*return*/, null];\n                        }\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        swReg = _a.sent();\n                        return [4 /*yield*/, this.getPublicVapidKey_()];\n                    case 2:\n                        publicVapidKey = _a.sent();\n                        return [4 /*yield*/, this.getPushSubscription(swReg, publicVapidKey)];\n                    case 3:\n                        pushSubscription = _a.sent();\n                        return [4 /*yield*/, this.tokenDetailsModel.getTokenDetailsFromSWScope(swReg.scope)];\n                    case 4:\n                        tokenDetails = _a.sent();\n                        if (tokenDetails) {\n                            return [2 /*return*/, this.manageExistingToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                        }\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    /**\n     * manageExistingToken is triggered if there's an existing FCM token in the\n     * database and it can take 3 different actions:\n     * 1) Retrieve the existing FCM token from the database.\n     * 2) If VAPID details have changed: Delete the existing token and create a\n     * new one with the new VAPID key.\n     * 3) If the database cache is invalidated: Send a request to FCM to update\n     * the token, and to check if the token is still valid on FCM-side.\n     */\n    BaseController.prototype.manageExistingToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            var isTokenValid, now;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        isTokenValid = isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails);\n                        if (isTokenValid) {\n                            now = Date.now();\n                            if (now < tokenDetails.createTime + TOKEN_EXPIRATION_MILLIS) {\n                                return [2 /*return*/, tokenDetails.fcmToken];\n                            }\n                            else {\n                                return [2 /*return*/, this.updateToken(swReg, pushSubscription, publicVapidKey, tokenDetails)];\n                            }\n                        }\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token from the FCM client and server\n                        // database. No need to unsubscribe from the Service Worker as we have a\n                        // good push subscription that we'd like to use in getNewToken.\n                        return [4 /*yield*/, this.deleteTokenFromDB(tokenDetails.fcmToken)];\n                    case 1:\n                        // If the token is no longer valid (for example if the VAPID details\n                        // have changed), delete the existing token from the FCM client and server\n                        // database. No need to unsubscribe from the Service Worker as we have a\n                        // good push subscription that we'd like to use in getNewToken.\n                        _a.sent();\n                        return [2 /*return*/, this.getNewToken(swReg, pushSubscription, publicVapidKey)];\n                }\n            });\n        });\n    };\n    BaseController.prototype.updateToken = function (swReg, pushSubscription, publicVapidKey, tokenDetails) {\n        return __awaiter(this, void 0, void 0, function () {\n            var updatedToken, allDetails, e_1;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 4, , 6]);\n                        return [4 /*yield*/, this.iidModel.updateToken(this.messagingSenderId, tokenDetails.fcmToken, tokenDetails.fcmPushSet, pushSubscription, publicVapidKey)];\n                    case 1:\n                        updatedToken = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            fcmSenderId: this.messagingSenderId,\n                            fcmToken: updatedToken,\n                            fcmPushSet: tokenDetails.fcmPushSet,\n                            createTime: Date.now(),\n                            endpoint: pushSubscription.endpoint,\n                            auth: pushSubscription.getKey('auth'),\n                            p256dh: pushSubscription.getKey('p256dh')\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, updatedToken];\n                    case 4:\n                        e_1 = _a.sent();\n                        return [4 /*yield*/, this.deleteToken(tokenDetails.fcmToken)];\n                    case 5:\n                        _a.sent();\n                        throw e_1;\n                    case 6: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    BaseController.prototype.getNewToken = function (swReg, pushSubscription, publicVapidKey) {\n        return __awaiter(this, void 0, void 0, function () {\n            var tokenDetails, allDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.iidModel.getToken(this.messagingSenderId, pushSubscription, publicVapidKey)];\n                    case 1:\n                        tokenDetails = _a.sent();\n                        allDetails = {\n                            swScope: swReg.scope,\n                            vapidKey: publicVapidKey,\n                            fcmSenderId: this.messagingSenderId,\n                            fcmToken: tokenDetails.token,\n                            fcmPushSet: tokenDetails.pushSet,\n                            createTime: Date.now(),\n                            endpoint: pushSubscription.endpoint,\n                            auth: pushSubscription.getKey('auth'),\n                            p256dh: pushSubscription.getKey('p256dh')\n                        };\n                        return [4 /*yield*/, this.tokenDetailsModel.saveTokenDetails(allDetails)];\n                    case 2:\n                        _a.sent();\n                        return [4 /*yield*/, this.vapidDetailsModel.saveVapidDetails(swReg.scope, publicVapidKey)];\n                    case 3:\n                        _a.sent();\n                        return [2 /*return*/, tokenDetails.token];\n                }\n            });\n        });\n    };\n    /**\n     * This method deletes tokens that the token manager looks after,\n     * unsubscribes the token from FCM  and then unregisters the push\n     * subscription if it exists. It returns a promise that indicates\n     * whether or not the unsubscribe request was processed successfully.\n     */\n    BaseController.prototype.deleteToken = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var registration, pushSubscription;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        // Delete the token details from the database.\n                        return [4 /*yield*/, this.deleteTokenFromDB(token)];\n                    case 1:\n                        // Delete the token details from the database.\n                        _a.sent();\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 2:\n                        registration = _a.sent();\n                        if (!registration)\n                            return [3 /*break*/, 4];\n                        return [4 /*yield*/, registration.pushManager.getSubscription()];\n                    case 3:\n                        pushSubscription = _a.sent();\n                        if (pushSubscription) {\n                            return [2 /*return*/, pushSubscription.unsubscribe()];\n                        }\n                        _a.label = 4;\n                    case 4:\n                        // If there's no SW, consider it a success.\n                        return [2 /*return*/, true];\n                }\n            });\n        });\n    };\n    /**\n     * This method will delete the token from the client database, and make a\n     * call to FCM to remove it from the server DB. Does not temper with the\n     * push subscription.\n     */\n    BaseController.prototype.deleteTokenFromDB = function (token) {\n        return __awaiter(this, void 0, void 0, function () {\n            var details;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.tokenDetailsModel.deleteToken(token)];\n                    case 1:\n                        details = _a.sent();\n                        return [4 /*yield*/, this.iidModel.deleteToken(details.fcmSenderId, details.fcmToken, details.fcmPushSet)];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Gets a PushSubscription for the current user.\n     */\n    BaseController.prototype.getPushSubscription = function (swRegistration, publicVapidKey) {\n        return swRegistration.pushManager.getSubscription().then(function (subscription) {\n            if (subscription) {\n                return subscription;\n            }\n            return swRegistration.pushManager.subscribe({\n                userVisibleOnly: true,\n                applicationServerKey: publicVapidKey\n            });\n        });\n    };\n    //\n    // The following methods should only be available in the window.\n    //\n    BaseController.prototype.requestPermission = function () {\n        throw errorFactory.create(\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */);\n    };\n    BaseController.prototype.useServiceWorker = function (registration) {\n        throw errorFactory.create(\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */);\n    };\n    BaseController.prototype.usePublicVapidKey = function (b64PublicKey) {\n        throw errorFactory.create(\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */);\n    };\n    BaseController.prototype.onMessage = function (nextOrObserver, error, completed) {\n        throw errorFactory.create(\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */);\n    };\n    BaseController.prototype.onTokenRefresh = function (nextOrObserver, error, completed) {\n        throw errorFactory.create(\"only-available-in-window\" /* AVAILABLE_IN_WINDOW */);\n    };\n    //\n    // The following methods are used by the service worker only.\n    //\n    BaseController.prototype.setBackgroundMessageHandler = function (callback) {\n        throw errorFactory.create(\"only-available-in-sw\" /* AVAILABLE_IN_SW */);\n    };\n    //\n    // The following methods are used by the service themselves and not exposed\n    // publicly or not expected to be used by developers.\n    //\n    /**\n     * This method is required to adhere to the Firebase interface.\n     * It closes any currently open indexdb database connections.\n     */\n    BaseController.prototype.delete = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, Promise.all([\n                            this.tokenDetailsModel.closeDatabase(),\n                            this.vapidDetailsModel.closeDatabase()\n                        ])];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * Returns the current Notification Permission state.\n     */\n    BaseController.prototype.getNotificationPermission_ = function () {\n        // TODO: Remove the cast when this issue is fixed:\n        // https://github.com/Microsoft/TypeScript/issues/14701\n        // tslint:disable-next-line no-any\n        return Notification.permission;\n    };\n    BaseController.prototype.getTokenDetailsModel = function () {\n        return this.tokenDetailsModel;\n    };\n    BaseController.prototype.getVapidDetailsModel = function () {\n        return this.vapidDetailsModel;\n    };\n    // Visible for testing\n    // TODO: make protected\n    BaseController.prototype.getIidModel = function () {\n        return this.iidModel;\n    };\n    return BaseController;\n}());\n/**\n * Checks if the tokenDetails match the details provided in the clients.\n */\nfunction isTokenStillValid(pushSubscription, publicVapidKey, tokenDetails) {\n    if (!tokenDetails.vapidKey ||\n        !isArrayBufferEqual(publicVapidKey.buffer, tokenDetails.vapidKey.buffer)) {\n        return false;\n    }\n    var isEndpointEqual = pushSubscription.endpoint === tokenDetails.endpoint;\n    var isAuthEqual = isArrayBufferEqual(pushSubscription.getKey('auth'), tokenDetails.auth);\n    var isP256dhEqual = isArrayBufferEqual(pushSubscription.getKey('p256dh'), tokenDetails.p256dh);\n    return isEndpointEqual && isAuthEqual && isP256dhEqual;\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar FCM_MSG = 'FCM_MSG';\nvar SwController = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(SwController, _super);\n    function SwController(app) {\n        var _this = _super.call(this, app) || this;\n        _this.bgMessageHandler = null;\n        self.addEventListener('push', function (e) {\n            _this.onPush(e);\n        });\n        self.addEventListener('pushsubscriptionchange', function (e) {\n            _this.onSubChange(e);\n        });\n        self.addEventListener('notificationclick', function (e) {\n            _this.onNotificationClick(e);\n        });\n        return _this;\n    }\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onPush = function (event) {\n        event.waitUntil(this.onPush_(event));\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onSubChange = function (event) {\n        event.waitUntil(this.onSubChange_(event));\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.onNotificationClick = function (event) {\n        event.waitUntil(this.onNotificationClick_(event));\n    };\n    /**\n     * A handler for push events that shows notifications based on the content of\n     * the payload.\n     *\n     * The payload must be a JSON-encoded Object with a `notification` key. The\n     * value of the `notification` property will be used as the NotificationOptions\n     * object passed to showNotification. Additionally, the `title` property of the\n     * notification object will be used as the title.\n     *\n     * If there is no notification data in the payload then no notification will be\n     * shown.\n     */\n    SwController.prototype.onPush_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var msgPayload, hasVisibleClients, notificationDetails, notificationTitle, reg, actions, maxActions;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!event.data) {\n                            return [2 /*return*/];\n                        }\n                        try {\n                            msgPayload = event.data.json();\n                        }\n                        catch (err) {\n                            // Not JSON so not an FCM message\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.hasVisibleClients_()];\n                    case 1:\n                        hasVisibleClients = _a.sent();\n                        if (hasVisibleClients) {\n                            // App in foreground. Send to page.\n                            return [2 /*return*/, this.sendMessageToWindowClients_(msgPayload)];\n                        }\n                        notificationDetails = this.getNotificationData_(msgPayload);\n                        if (!notificationDetails)\n                            return [3 /*break*/, 3];\n                        notificationTitle = notificationDetails.title || '';\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 2:\n                        reg = _a.sent();\n                        actions = notificationDetails.actions;\n                        maxActions = Notification.maxActions;\n                        // tslint:enable no-any\n                        if (actions && maxActions && actions.length > maxActions) {\n                            console.warn(\"This browser only supports \" + maxActions + \" actions.\" +\n                                \"The remaining actions will not be displayed.\");\n                        }\n                        return [2 /*return*/, reg.showNotification(notificationTitle, notificationDetails)];\n                    case 3:\n                        if (!this.bgMessageHandler)\n                            return [3 /*break*/, 5];\n                        return [4 /*yield*/, this.bgMessageHandler(msgPayload)];\n                    case 4:\n                        _a.sent();\n                        return [2 /*return*/];\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SwController.prototype.onSubChange_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var registration, err_1, err_2, tokenDetailsModel, tokenDetails;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        _a.trys.push([0, 2, , 3]);\n                        return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        registration = _a.sent();\n                        return [3 /*break*/, 3];\n                    case 2:\n                        err_1 = _a.sent();\n                        throw errorFactory.create(\"unable-to-resubscribe\" /* UNABLE_TO_RESUBSCRIBE */, {\n                            message: err_1\n                        });\n                    case 3:\n                        _a.trys.push([3, 5, , 8]);\n                        return [4 /*yield*/, registration.pushManager.getSubscription()];\n                    case 4:\n                        _a.sent();\n                        return [3 /*break*/, 8];\n                    case 5:\n                        err_2 = _a.sent();\n                        tokenDetailsModel = this.getTokenDetailsModel();\n                        return [4 /*yield*/, tokenDetailsModel.getTokenDetailsFromSWScope(registration.scope)];\n                    case 6:\n                        tokenDetails = _a.sent();\n                        if (!tokenDetails) {\n                            // This should rarely occure, but could if indexedDB\n                            // is corrupted or wiped\n                            throw err_2;\n                        }\n                        // Attempt to delete the token if we know it's bad\n                        return [4 /*yield*/, this.deleteToken(tokenDetails.fcmToken)];\n                    case 7:\n                        // Attempt to delete the token if we know it's bad\n                        _a.sent();\n                        throw err_2;\n                    case 8: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    SwController.prototype.onNotificationClick_ = function (event) {\n        return __awaiter(this, void 0, void 0, function () {\n            var msgPayload, link, windowClient, internalMsg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!event.notification ||\n                            !event.notification.data ||\n                            !event.notification.data[FCM_MSG]) {\n                            // Not an FCM notification, do nothing.\n                            return [2 /*return*/];\n                        }\n                        else if (event.action) {\n                            // User clicked on an action button.\n                            // This will allow devs to act on action button clicks by using a custom\n                            // onNotificationClick listener that they define.\n                            return [2 /*return*/];\n                        }\n                        // Prevent other listeners from receiving the event\n                        event.stopImmediatePropagation();\n                        event.notification.close();\n                        msgPayload = event.notification.data[FCM_MSG];\n                        if (!msgPayload.notification) {\n                            // Nothing to do.\n                            return [2 /*return*/];\n                        }\n                        link = (msgPayload.fcmOptions && msgPayload.fcmOptions.link) ||\n                            msgPayload.notification.click_action;\n                        if (!link) {\n                            // Nothing to do.\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, this.getWindowClient_(link)];\n                    case 1:\n                        windowClient = _a.sent();\n                        if (!!windowClient)\n                            return [3 /*break*/, 3];\n                        return [4 /*yield*/, self.clients.openWindow(link)];\n                    case 2:\n                        // Unable to find window client so need to open one.\n                        windowClient = _a.sent();\n                        return [3 /*break*/, 5];\n                    case 3: return [4 /*yield*/, windowClient.focus()];\n                    case 4:\n                        windowClient = _a.sent();\n                        _a.label = 5;\n                    case 5:\n                        if (!windowClient) {\n                            // Window Client will not be returned if it's for a third party origin.\n                            return [2 /*return*/];\n                        }\n                        // Delete notification and fcmOptions data from payload before sending to\n                        // the page.\n                        delete msgPayload.notification;\n                        delete msgPayload.fcmOptions;\n                        internalMsg = createNewMsg(MessageType.NOTIFICATION_CLICKED, msgPayload);\n                        // Attempt to send a message to the client to handle the data\n                        // Is affected by: https://github.com/slightlyoff/ServiceWorker/issues/728\n                        return [2 /*return*/, this.attemptToMessageClient_(windowClient, internalMsg)];\n                }\n            });\n        });\n    };\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.getNotificationData_ = function (msgPayload) {\n        var _a;\n        if (!msgPayload) {\n            return;\n        }\n        if (typeof msgPayload.notification !== 'object') {\n            return;\n        }\n        var notificationInformation = __assign({}, msgPayload.notification);\n        // Put the message payload under FCM_MSG name so we can identify the\n        // notification as being an FCM notification vs a notification from\n        // somewhere else (i.e. normal web push or developer generated\n        // notification).\n        notificationInformation.data = __assign({}, msgPayload.notification.data, (_a = {}, _a[FCM_MSG] = msgPayload, _a));\n        return notificationInformation;\n    };\n    /**\n     * Calling setBackgroundMessageHandler will opt in to some specific\n     * behaviours.\n     * 1.) If a notification doesn't need to be shown due to a window already\n     * being visible, then push messages will be sent to the page.\n     * 2.) If a notification needs to be shown, and the message contains no\n     * notification data this method will be called\n     * and the promise it returns will be passed to event.waitUntil.\n     * If you do not set this callback then all push messages will let and the\n     * developer can handle them in a their own 'push' event callback\n     *\n     * @param callback The callback to be called when a push message is received\n     * and a notification must be shown. The callback will be given the data from\n     * the push message.\n     */\n    SwController.prototype.setBackgroundMessageHandler = function (callback) {\n        if (!callback || typeof callback !== 'function') {\n            throw errorFactory.create(\"bg-handler-function-expected\" /* BG_HANDLER_FUNCTION_EXPECTED */);\n        }\n        this.bgMessageHandler = callback;\n    };\n    /**\n     * @param url The URL to look for when focusing a client.\n     * @return Returns an existing window client or a newly opened WindowClient.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.getWindowClient_ = function (url) {\n        return __awaiter(this, void 0, void 0, function () {\n            var parsedURL, clientList, suitableClient, i, parsedClientUrl;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        parsedURL = new URL(url, self.location.href).href;\n                        return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        suitableClient = null;\n                        for (i = 0; i < clientList.length; i++) {\n                            parsedClientUrl = new URL(clientList[i].url, self.location.href)\n                                .href;\n                            if (parsedClientUrl === parsedURL) {\n                                suitableClient = clientList[i];\n                                break;\n                            }\n                        }\n                        return [2 /*return*/, suitableClient];\n                }\n            });\n        });\n    };\n    /**\n     * This message will attempt to send the message to a window client.\n     * @param client The WindowClient to send the message to.\n     * @param message The message to send to the client.\n     * @returns Returns a promise that resolves after sending the message. This\n     * does not guarantee that the message was successfully received.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.attemptToMessageClient_ = function (client, message) {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                // NOTE: This returns a promise in case this API is abstracted later on to\n                // do additional work\n                if (!client) {\n                    throw errorFactory.create(\"no-window-client-to-msg\" /* NO_WINDOW_CLIENT_TO_MSG */);\n                }\n                client.postMessage(message);\n                return [2 /*return*/];\n            });\n        });\n    };\n    /**\n     * @returns If there is currently a visible WindowClient, this method will\n     * resolve to true, otherwise false.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.hasVisibleClients_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var clientList;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        return [2 /*return*/, clientList.some(function (client) {\n                                return client.visibilityState === 'visible' &&\n                                    // Ignore chrome-extension clients as that matches the background pages\n                                    // of extensions, which are always considered visible.\n                                    !client.url.startsWith('chrome-extension://');\n                            })];\n                }\n            });\n        });\n    };\n    /**\n     * @param msgPayload The data from the push event that should be sent to all\n     * available pages.\n     * @returns Returns a promise that resolves once the message has been sent to\n     * all WindowClients.\n     */\n    // Visible for testing\n    // TODO: Make private\n    SwController.prototype.sendMessageToWindowClients_ = function (msgPayload) {\n        return __awaiter(this, void 0, void 0, function () {\n            var clientList, internalMsg;\n            var _this = this;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, getClientList()];\n                    case 1:\n                        clientList = _a.sent();\n                        internalMsg = createNewMsg(MessageType.PUSH_MSG_RECEIVED, msgPayload);\n                        return [4 /*yield*/, Promise.all(clientList.map(function (client) {\n                                return _this.attemptToMessageClient_(client, internalMsg);\n                            }))];\n                    case 2:\n                        _a.sent();\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This will register the default service worker and return the registration.\n     * @return he service worker registration to be used for the push service.\n     */\n    SwController.prototype.getSWRegistration_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                return [2 /*return*/, self.registration];\n            });\n        });\n    };\n    /**\n     * This will return the default VAPID key or the uint8array version of the\n     * public VAPID key provided by the developer.\n     */\n    SwController.prototype.getPublicVapidKey_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var swReg, vapidKeyFromDatabase;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0: return [4 /*yield*/, this.getSWRegistration_()];\n                    case 1:\n                        swReg = _a.sent();\n                        if (!swReg) {\n                            throw errorFactory.create(\"sw-registration-expected\" /* SW_REGISTRATION_EXPECTED */);\n                        }\n                        return [4 /*yield*/, this.getVapidDetailsModel().getVapidFromSWScope(swReg.scope)];\n                    case 2:\n                        vapidKeyFromDatabase = _a.sent();\n                        if (vapidKeyFromDatabase == null) {\n                            return [2 /*return*/, DEFAULT_PUBLIC_VAPID_KEY];\n                        }\n                        return [2 /*return*/, vapidKeyFromDatabase];\n                }\n            });\n        });\n    };\n    return SwController;\n}(BaseController));\nfunction getClientList() {\n    return self.clients.matchAll({\n        type: 'window',\n        includeUncontrolled: true\n        // TS doesn't know that \"type: 'window'\" means it'll return WindowClient[]\n    });\n}\nfunction createNewMsg(msgType, msgData) {\n    var _a;\n    return _a = {},\n        _a[MessageParameter.TYPE_OF_MSG] = msgType,\n        _a[MessageParameter.DATA] = msgData,\n        _a;\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar DEFAULT_SW_PATH = '/firebase-messaging-sw.js';\nvar DEFAULT_SW_SCOPE = '/firebase-cloud-messaging-push-scope';\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar WindowController = /** @class */ /*@__PURE__*/ (function (_super) {\n    __extends(WindowController, _super);\n    /**\n     * A service that provides a MessagingService instance.\n     */\n    function WindowController(app) {\n        var _this = _super.call(this, app) || this;\n        _this.registrationToUse = null;\n        _this.publicVapidKeyToUse = null;\n        _this.manifestCheckPromise = null;\n        _this.messageObserver = null;\n        // @ts-ignore: Unused variable error, this is not implemented yet.\n        _this.tokenRefreshObserver = null;\n        _this.onMessageInternal = createSubscribe(function (observer) {\n            _this.messageObserver = observer;\n        });\n        _this.onTokenRefreshInternal = createSubscribe(function (observer) {\n            _this.tokenRefreshObserver = observer;\n        });\n        _this.setupSWMessageListener_();\n        return _this;\n    }\n    /**\n     * This method returns an FCM token if it can be generated.\n     * The return promise will reject if the browser doesn't support\n     * FCM, if permission is denied for notifications or it's not\n     * possible to generate a token.\n     *\n     * @return Returns a promise that resolves to an FCM token or null if\n     * permission isn't granted.\n     */\n    WindowController.prototype.getToken = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (!this.manifestCheckPromise) {\n                            this.manifestCheckPromise = manifestCheck();\n                        }\n                        return [4 /*yield*/, this.manifestCheckPromise];\n                    case 1:\n                        _a.sent();\n                        return [2 /*return*/, _super.prototype.getToken.call(this)];\n                }\n            });\n        });\n    };\n    /**\n     * Request permission if it is not currently granted\n     *\n     * @return Resolves if the permission was granted, otherwise rejects\n     */\n    WindowController.prototype.requestPermission = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            var permissionResult;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (this.getNotificationPermission_() === 'granted') {\n                            return [2 /*return*/];\n                        }\n                        return [4 /*yield*/, Notification.requestPermission()];\n                    case 1:\n                        permissionResult = _a.sent();\n                        if (permissionResult === 'granted') {\n                            return [2 /*return*/];\n                        }\n                        else if (permissionResult === 'denied') {\n                            throw errorFactory.create(\"permission-blocked\" /* PERMISSION_BLOCKED */);\n                        }\n                        else {\n                            throw errorFactory.create(\"permission-default\" /* PERMISSION_DEFAULT */);\n                        }\n                        return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * This method allows a developer to override the default service worker and\n     * instead use a custom service worker.\n     *\n     * @param registration The service worker registration that should be used to\n     * receive the push messages.\n     */\n    WindowController.prototype.useServiceWorker = function (registration) {\n        if (!(registration instanceof ServiceWorkerRegistration)) {\n            throw errorFactory.create(\"sw-registration-expected\" /* SW_REGISTRATION_EXPECTED */);\n        }\n        if (this.registrationToUse != null) {\n            throw errorFactory.create(\"use-sw-before-get-token\" /* USE_SW_BEFORE_GET_TOKEN */);\n        }\n        this.registrationToUse = registration;\n    };\n    /**\n     * This method allows a developer to override the default vapid key\n     * and instead use a custom VAPID public key.\n     *\n     * @param publicKey A URL safe base64 encoded string.\n     */\n    WindowController.prototype.usePublicVapidKey = function (publicKey) {\n        if (typeof publicKey !== 'string') {\n            throw errorFactory.create(\"invalid-public-vapid-key\" /* INVALID_PUBLIC_VAPID_KEY */);\n        }\n        if (this.publicVapidKeyToUse != null) {\n            throw errorFactory.create(\"use-public-key-before-get-token\" /* USE_PUBLIC_KEY_BEFORE_GET_TOKEN */);\n        }\n        var parsedKey = base64ToArrayBuffer(publicKey);\n        if (parsedKey.length !== 65) {\n            throw errorFactory.create(\"public-vapid-key-decryption-failed\" /* PUBLIC_KEY_DECRYPTION_FAILED */);\n        }\n        this.publicVapidKeyToUse = parsedKey;\n    };\n    /**\n     * @export\n     * @param nextOrObserver An observer object or a function triggered on\n     * message.\n     * @param error A function triggered on message error.\n     * @param completed function triggered when the observer is removed.\n     * @return The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onMessage = function (nextOrObserver, error, completed) {\n        if (typeof nextOrObserver === 'function') {\n            return this.onMessageInternal(nextOrObserver, error, completed);\n        }\n        else {\n            return this.onMessageInternal(nextOrObserver);\n        }\n    };\n    /**\n     * @param nextOrObserver An observer object or a function triggered on token\n     * refresh.\n     * @param error A function triggered on token refresh error.\n     * @param completed function triggered when the observer is removed.\n     * @return The unsubscribe function for the observer.\n     */\n    WindowController.prototype.onTokenRefresh = function (nextOrObserver, error, completed) {\n        if (typeof nextOrObserver === 'function') {\n            return this.onTokenRefreshInternal(nextOrObserver, error, completed);\n        }\n        else {\n            return this.onTokenRefreshInternal(nextOrObserver);\n        }\n    };\n    /**\n     * Given a registration, wait for the service worker it relates to\n     * become activer\n     * @param registration Registration to wait for service worker to become active\n     * @return Wait for service worker registration to become active\n     */\n    // Visible for testing\n    // TODO: Make private\n    WindowController.prototype.waitForRegistrationToActivate_ = function (registration) {\n        var serviceWorker = registration.installing || registration.waiting || registration.active;\n        return new Promise(function (resolve, reject) {\n            if (!serviceWorker) {\n                // This is a rare scenario but has occured in firefox\n                reject(errorFactory.create(\"no-sw-in-reg\" /* NO_SW_IN_REG */));\n                return;\n            }\n            // Because the Promise function is called on next tick there is a\n            // small chance that the worker became active or redundant already.\n            if (serviceWorker.state === 'activated') {\n                resolve(registration);\n                return;\n            }\n            if (serviceWorker.state === 'redundant') {\n                reject(errorFactory.create(\"sw-reg-redundant\" /* SW_REG_REDUNDANT */));\n                return;\n            }\n            var stateChangeListener = function () {\n                if (serviceWorker.state === 'activated') {\n                    resolve(registration);\n                }\n                else if (serviceWorker.state === 'redundant') {\n                    reject(errorFactory.create(\"sw-reg-redundant\" /* SW_REG_REDUNDANT */));\n                }\n                else {\n                    // Return early and wait to next state change\n                    return;\n                }\n                serviceWorker.removeEventListener('statechange', stateChangeListener);\n            };\n            serviceWorker.addEventListener('statechange', stateChangeListener);\n        });\n    };\n    /**\n     * This will register the default service worker and return the registration\n     * @return The service worker registration to be used for the push service.\n     */\n    WindowController.prototype.getSWRegistration_ = function () {\n        var _this = this;\n        if (this.registrationToUse) {\n            return this.waitForRegistrationToActivate_(this.registrationToUse);\n        }\n        // Make the registration null so we know useServiceWorker will not\n        // use a new service worker as registrationToUse is no longer undefined\n        this.registrationToUse = null;\n        return navigator.serviceWorker\n            .register(DEFAULT_SW_PATH, {\n            scope: DEFAULT_SW_SCOPE\n        })\n            .catch(function (err) {\n            throw errorFactory.create(\"failed-serviceworker-registration\" /* FAILED_DEFAULT_REGISTRATION */, {\n                browserErrorMessage: err.message\n            });\n        })\n            .then(function (registration) {\n            return _this.waitForRegistrationToActivate_(registration).then(function () {\n                _this.registrationToUse = registration;\n                // We update after activation due to an issue with Firefox v49 where\n                // a race condition occassionally causes the service work to not\n                // install\n                registration.update();\n                return registration;\n            });\n        });\n    };\n    /**\n     * This will return the default VAPID key or the uint8array version of the public VAPID key\n     * provided by the developer.\n     */\n    WindowController.prototype.getPublicVapidKey_ = function () {\n        return __awaiter(this, void 0, void 0, function () {\n            return __generator(this, function (_a) {\n                if (this.publicVapidKeyToUse) {\n                    return [2 /*return*/, this.publicVapidKeyToUse];\n                }\n                return [2 /*return*/, DEFAULT_PUBLIC_VAPID_KEY];\n            });\n        });\n    };\n    /**\n     * This method will set up a message listener to handle\n     * events from the service worker that should trigger\n     * events in the page.\n     */\n    // Visible for testing\n    // TODO: Make private\n    WindowController.prototype.setupSWMessageListener_ = function () {\n        var _this = this;\n        navigator.serviceWorker.addEventListener('message', function (event) {\n            if (!event.data || !event.data[MessageParameter.TYPE_OF_MSG]) {\n                // Not a message from FCM\n                return;\n            }\n            var workerPageMessage = event.data;\n            switch (workerPageMessage[MessageParameter.TYPE_OF_MSG]) {\n                case MessageType.PUSH_MSG_RECEIVED:\n                case MessageType.NOTIFICATION_CLICKED:\n                    var pushMessage = workerPageMessage[MessageParameter.DATA];\n                    if (_this.messageObserver) {\n                        _this.messageObserver.next(pushMessage);\n                    }\n                    break;\n                default:\n                    // Noop.\n                    break;\n            }\n        }, false);\n    };\n    return WindowController;\n}(BaseController));\n/**\n * The method checks that a manifest is defined and has the correct GCM\n * sender ID.\n * @return Returns a promise that resolves if the manifest matches\n * our required sender ID\n */\n// Exported for testing\nfunction manifestCheck() {\n    return __awaiter(this, void 0, void 0, function () {\n        var manifestTag, manifestContent, response, e_1;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    manifestTag = document.querySelector('link[rel=\"manifest\"]');\n                    if (!manifestTag) {\n                        return [2 /*return*/];\n                    }\n                    _a.label = 1;\n                case 1:\n                    _a.trys.push([1, 4, , 5]);\n                    return [4 /*yield*/, fetch(manifestTag.href)];\n                case 2:\n                    response = _a.sent();\n                    return [4 /*yield*/, response.json()];\n                case 3:\n                    manifestContent = _a.sent();\n                    return [3 /*break*/, 5];\n                case 4:\n                    e_1 = _a.sent();\n                    // If the download or parsing fails allow check.\n                    // We only want to error if we KNOW that the gcm_sender_id is incorrect.\n                    return [2 /*return*/];\n                case 5:\n                    if (!manifestContent || !manifestContent.gcm_sender_id) {\n                        return [2 /*return*/];\n                    }\n                    if (manifestContent.gcm_sender_id !== '103953800507') {\n                        throw errorFactory.create(\"incorrect-gcm-sender-id\" /* INCORRECT_GCM_SENDER_ID */);\n                    }\n                    return [2 /*return*/];\n            }\n        });\n    });\n}\n/**\n * @license\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nfunction registerMessaging(instance) {\n    var messagingName = 'messaging';\n    var factoryMethod = function (app) {\n        if (!isSupported()) {\n            throw errorFactory.create(\"unsupported-browser\" /* UNSUPPORTED_BROWSER */);\n        }\n        if (self && 'ServiceWorkerGlobalScope' in self) {\n            // Running in ServiceWorker context\n            return new SwController(app);\n        }\n        else {\n            // Assume we are in the window context.\n            return new WindowController(app);\n        }\n    };\n    var namespaceExports = {\n        isSupported: isSupported\n    };\n    instance.INTERNAL.registerService(messagingName, factoryMethod, namespaceExports);\n}\nregisterMessaging(firebase);\nfunction isSupported() {\n    if (self && 'ServiceWorkerGlobalScope' in self) {\n        // Running in ServiceWorker context\n        return isSWControllerSupported();\n    }\n    else {\n        // Assume we are in the window context.\n        return isWindowControllerSupported();\n    }\n}\n/**\n * Checks to see if the required APIs exist.\n */\nfunction isWindowControllerSupported() {\n    return (navigator.cookieEnabled &&\n        'serviceWorker' in navigator &&\n        'PushManager' in window &&\n        'Notification' in window &&\n        'fetch' in window &&\n        ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n        PushSubscription.prototype.hasOwnProperty('getKey'));\n}\n/**\n * Checks to see if the required APIs exist within SW Context.\n */\nfunction isSWControllerSupported() {\n    return ('PushManager' in self &&\n        'Notification' in self &&\n        ServiceWorkerRegistration.prototype.hasOwnProperty('showNotification') &&\n        PushSubscription.prototype.hasOwnProperty('getKey'));\n}\nexport { isSupported, registerMessaging };\n//# sourceMappingURL=index.esm.js.map\n",null]}