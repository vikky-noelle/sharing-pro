"use strict";
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
Object.defineProperty(exports, "__esModule", { value: true });
// Matches <%= expr %>. This does not support structural JavaScript (for/if/...).
const kInterpolateRe = /<%=([\s\S]+?)%>/g;
// Used to match template delimiters.
// <%- expr %>: HTML escape the value.
// <% ... %>: Structural template code.
const kEscapeRe = /<%-([\s\S]+?)%>/g;
const kEvaluateRe = /<%([\s\S]+?)%>/g;
/** Used to map characters to HTML entities. */
const kHtmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '`': '&#96;'
};
// Used to match HTML entities and HTML characters.
const reUnescapedHtml = new RegExp(`[${Object.keys(kHtmlEscapes).join('')}]`, 'g');
// Used to match empty string literals in compiled template source.
const reEmptyStringLeading = /\b__p \+= '';/g;
const reEmptyStringMiddle = /\b(__p \+=) '' \+/g;
const reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
// Used to escape characters for inclusion in compiled string literals.
const stringEscapes = {
    '\\': '\\\\',
    "'": "\\'",
    '\n': '\\n',
    '\r': '\\r',
    '\u2028': '\\u2028',
    '\u2029': '\\u2029'
};
// Used to match unescaped characters in compiled string literals.
const reUnescapedString = /['\n\r\u2028\u2029\\]/g;
function _escape(s) {
    return s ? s.replace(reUnescapedHtml, key => kHtmlEscapes[key]) : '';
}
/**
 * An equivalent of lodash templates, which is based on John Resig's `tmpl` implementation
 * (http://ejohn.org/blog/javascript-micro-templating/) and Laura Doktorova's doT.js
 * (https://github.com/olado/doT).
 *
 * This version differs from lodash by removing support from ES6 quasi-literals, and making the
 * code slightly simpler to follow. It also does not depend on any third party, which is nice.
 *
 * @param content
 * @param options
 * @return {any}
 */
function template(content, options) {
    const interpolate = kInterpolateRe;
    let isEvaluating;
    let index = 0;
    let source = `__p += '`;
    // Compile the regexp to match each delimiter.
    const reDelimiters = RegExp(`${kEscapeRe.source}|${interpolate.source}|${kEvaluateRe.source}|$`, 'g');
    // Use a sourceURL for easier debugging.
    const sourceURL = options.sourceURL ? '//# sourceURL=' + options.sourceURL + '\n' : '';
    content.replace(reDelimiters, (match, escapeValue, interpolateValue, evaluateValue, offset) => {
        // Escape characters that can't be included in string literals.
        source += content.slice(index, offset).replace(reUnescapedString, chr => stringEscapes[chr]);
        // Replace delimiters with snippets.
        if (escapeValue) {
            source += `' +\n__e(${escapeValue}) +\n  '`;
        }
        if (evaluateValue) {
            isEvaluating = true;
            source += `';\n${evaluateValue};\n__p += '`;
        }
        if (interpolateValue) {
            source += `' +\n((__t = (${interpolateValue})) == null ? '' : __t) +\n  '`;
        }
        index = offset + match.length;
        return match;
    });
    source += "';\n";
    // Cleanup code by stripping empty strings.
    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');
    // Frame code as the function body.
    source = `
  return function(obj) {
    obj || (obj = {});
    let __t;
    let __p = '';
    const __e = _.escape;
    with (obj) {
      ${source.replace(/\n/g, '\n      ')}
    }
    return __p;
  };
  `;
    const fn = Function('_', sourceURL + source);
    const result = fn({ escape: _escape });
    // Provide the compiled function's source by its `toString` method or
    // the `source` property as a convenience for inlining compiled templates.
    result.source = source;
    return result;
}
exports.template = template;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVtcGxhdGUuanMiLCJzb3VyY2VSb290IjoiL1VzZXJzL2hhbnNsL1NvdXJjZXMvZGV2a2l0LyIsInNvdXJjZXMiOlsicGFja2FnZXMvYW5ndWxhcl9kZXZraXQvc2NoZW1hdGljcy9zcmMvcnVsZXMvdGVtcGxhdGUvdGVtcGxhdGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7Ozs7R0FNRzs7QUFFSCxpRkFBaUY7QUFDakYsTUFBTSxjQUFjLEdBQUcsa0JBQWtCLENBQUM7QUFFMUMscUNBQXFDO0FBQ3JDLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsTUFBTSxTQUFTLEdBQUcsa0JBQWtCLENBQUM7QUFDckMsTUFBTSxXQUFXLEdBQUcsaUJBQWlCLENBQUM7QUFFdEMsK0NBQStDO0FBQy9DLE1BQU0sWUFBWSxHQUE2QjtJQUM3QyxHQUFHLEVBQUUsT0FBTztJQUNaLEdBQUcsRUFBRSxNQUFNO0lBQ1gsR0FBRyxFQUFFLE1BQU07SUFDWCxHQUFHLEVBQUUsUUFBUTtJQUNiLEdBQUcsRUFBRSxPQUFPO0lBQ1osR0FBRyxFQUFFLE9BQU87Q0FDYixDQUFDO0FBRUYsbURBQW1EO0FBQ25ELE1BQU0sZUFBZSxHQUFHLElBQUksTUFBTSxDQUFDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQVFuRixtRUFBbUU7QUFDbkUsTUFBTSxvQkFBb0IsR0FBRyxnQkFBZ0IsQ0FBQztBQUM5QyxNQUFNLG1CQUFtQixHQUFHLG9CQUFvQixDQUFDO0FBQ2pELE1BQU0scUJBQXFCLEdBQUcsK0JBQStCLENBQUM7QUFHOUQsdUVBQXVFO0FBQ3ZFLE1BQU0sYUFBYSxHQUE2QjtJQUM5QyxJQUFJLEVBQUUsTUFBTTtJQUNaLEdBQUcsRUFBRSxLQUFLO0lBQ1YsSUFBSSxFQUFFLEtBQUs7SUFDWCxJQUFJLEVBQUUsS0FBSztJQUNYLFFBQVEsRUFBRSxTQUFT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LyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG4vLyBNYXRjaGVzIDwlPSBleHByICU+LiBUaGlzIGRvZXMgbm90IHN1cHBvcnQgc3RydWN0dXJhbCBKYXZhU2NyaXB0IChmb3IvaWYvLi4uKS5cbmNvbnN0IGtJbnRlcnBvbGF0ZVJlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbi8vIFVzZWQgdG8gbWF0Y2ggdGVtcGxhdGUgZGVsaW1pdGVycy5cbi8vIDwlLSBleHByICU+OiBIVE1MIGVzY2FwZSB0aGUgdmFsdWUuXG4vLyA8JSAuLi4gJT46IFN0cnVjdHVyYWwgdGVtcGxhdGUgY29kZS5cbmNvbnN0IGtFc2NhcGVSZSA9IC88JS0oW1xcc1xcU10rPyklPi9nO1xuY29uc3Qga0V2YWx1YXRlUmUgPSAvPCUoW1xcc1xcU10rPyklPi9nO1xuXG4vKiogVXNlZCB0byBtYXAgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLiAqL1xuY29uc3Qga0h0bWxFc2NhcGVzOiB7W2NoYXI6IHN0cmluZ106IHN0cmluZ30gPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmIzM5OycsXG4gICdgJzogJyYjOTY7J1xufTtcblxuLy8gVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzIGFuZCBIVE1MIGNoYXJhY3RlcnMuXG5jb25zdCByZVVuZXNjYXBlZEh0bWwgPSBuZXcgUmVnRXhwKGBbJHtPYmplY3Qua2V5cyhrSHRtbEVzY2FwZXMpLmpvaW4oJycpfV1gLCAnZycpO1xuXG4vLyBPcHRpb25zIHRvIHBhc3MgdG8gdGVtcGxhdGUuXG5leHBvcnQgaW50ZXJmYWNlIFRlbXBsYXRlT3B0aW9ucyB7XG4gIHNvdXJjZVVSTD86IHN0cmluZztcbn1cblxuXG4vLyBVc2VkIHRvIG1hdGNoIGVtcHR5IHN0cmluZyBsaXRlcmFscyBpbiBjb21waWxlZCB0ZW1wbGF0ZSBzb3VyY2UuXG5jb25zdCByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZztcbmNvbnN0IHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZztcbmNvbnN0IHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cblxuLy8gVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbmNvbnN0IHN0cmluZ0VzY2FwZXM6IHtbY2hhcjogc3RyaW5nXTogc3RyaW5nfSA9IHtcbiAgJ1xcXFwnOiAnXFxcXFxcXFwnLFxuICBcIidcIjogXCJcXFxcJ1wiLFxuICAnXFxuJzogJ1xcXFxuJyxcbiAgJ1xccic6ICdcXFxccicsXG4gICdcXHUyMDI4JzogJ1xcXFx1MjAyOCcsXG4gICdcXHUyMDI5JzogJ1xcXFx1MjAyOSdcbn07XG5cbi8vIFVzZWQgdG8gbWF0Y2ggdW5lc2NhcGVkIGNoYXJhY3RlcnMgaW4gY29tcGlsZWQgc3RyaW5nIGxpdGVyYWxzLlxuY29uc3QgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cblxuZnVuY3Rpb24gX2VzY2FwZShzOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHMgPyBzLnJlcGxhY2UocmVVbmVzY2FwZWRIdG1sLCBrZXkgPT4ga0h0bWxFc2NhcGVzW2tleV0pIDogJyc7XG59XG5cblxuLyoqXG4gKiBBbiBlcXVpdmFsZW50IG9mIGxvZGFzaCB0ZW1wbGF0ZXMsIHdoaWNoIGlzIGJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAqIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLykgYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICogKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICpcbiAqIFRoaXMgdmVyc2lvbiBkaWZmZXJzIGZyb20gbG9kYXNoIGJ5IHJlbW92aW5nIHN1cHBvcnQgZnJvbSBFUzYgcXVhc2ktbGl0ZXJhbHMsIGFuZCBtYWtpbmcgdGhlXG4gKiBjb2RlIHNsaWdodGx5IHNpbXBsZXIgdG8gZm9sbG93LiBJdCBhbHNvIGRvZXMgbm90IGRlcGVuZCBvbiBhbnkgdGhpcmQgcGFydHksIHdoaWNoIGlzIG5pY2UuXG4gKlxuICogQHBhcmFtIGNvbnRlbnRcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiBAcmV0dXJuIHthbnl9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZTxUPihjb250ZW50OiBzdHJpbmcsIG9wdGlvbnM6IFRlbXBsYXRlT3B0aW9ucyk6IChpbnB1dDogVCkgPT4gc3RyaW5nIHtcbiAgY29uc3QgaW50ZXJwb2xhdGUgPSBrSW50ZXJwb2xhdGVSZTtcbiAgbGV0IGlzRXZhbHVhdGluZztcbiAgbGV0IGluZGV4ID0gMDtcbiAgbGV0IHNvdXJjZSA9IGBfX3AgKz0gJ2A7XG5cbiAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICBjb25zdCByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgYCR7a0VzY2FwZVJlLnNvdXJjZX18JHtpbnRlcnBvbGF0ZS5zb3VyY2V9fCR7a0V2YWx1YXRlUmUuc291cmNlfXwkYCwgJ2cnKTtcblxuICAvLyBVc2UgYSBzb3VyY2VVUkwgZm9yIGVhc2llciBkZWJ1Z2dpbmcuXG4gIGNvbnN0IHNvdXJjZVVSTCA9IG9wdGlvbnMuc291cmNlVVJMID8gJy8vIyBzb3VyY2VVUkw9JyArIG9wdGlvbnMuc291cmNlVVJMICsgJ1xcbicgOiAnJztcblxuICBjb250ZW50LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCAobWF0Y2gsIGVzY2FwZVZhbHVlLCBpbnRlcnBvbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpID0+IHtcbiAgICAvLyBFc2NhcGUgY2hhcmFjdGVycyB0aGF0IGNhbid0IGJlIGluY2x1ZGVkIGluIHN0cmluZyBsaXRlcmFscy5cbiAgICBzb3VyY2UgKz0gY29udGVudC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBjaHIgPT4gc3RyaW5nRXNjYXBlc1tjaHJdKTtcblxuICAgIC8vIFJlcGxhY2UgZGVsaW1pdGVycyB3aXRoIHNuaXBwZXRzLlxuICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgc291cmNlICs9IGAnICtcXG5fX2UoJHtlc2NhcGVWYWx1ZX0pICtcXG4gICdgO1xuICAgIH1cbiAgICBpZiAoZXZhbHVhdGVWYWx1ZSkge1xuICAgICAgaXNFdmFsdWF0aW5nID0gdHJ1ZTtcbiAgICAgIHNvdXJjZSArPSBgJztcXG4ke2V2YWx1YXRlVmFsdWV9O1xcbl9fcCArPSAnYDtcbiAgICB9XG4gICAgaWYgKGludGVycG9sYXRlVmFsdWUpIHtcbiAgICAgIHNvdXJjZSArPSBgJyArXFxuKChfX3QgPSAoJHtpbnRlcnBvbGF0ZVZhbHVlfSkpID09IG51bGwgPyAnJyA6IF9fdCkgK1xcbiAgJ2A7XG4gICAgfVxuICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9KTtcblxuICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ01pZGRsZSwgJyQxJylcbiAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAvLyBGcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5LlxuICBzb3VyY2UgPSBgXG4gIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICBvYmogfHwgKG9iaiA9IHt9KTtcbiAgICBsZXQgX190O1xuICAgIGxldCBfX3AgPSAnJztcbiAgICBjb25zdCBfX2UgPSBfLmVzY2FwZTtcbiAgICB3aXRoIChvYmopIHtcbiAgICAgICR7c291cmNlLnJlcGxhY2UoL1xcbi9nLCAnXFxuICAgICAgJyl9XG4gICAgfVxuICAgIHJldHVybiBfX3A7XG4gIH07XG4gIGA7XG5cbiAgY29uc3QgZm4gPSBGdW5jdGlvbignXycsIHNvdXJjZVVSTCArIHNvdXJjZSk7XG4gIGNvbnN0IHJlc3VsdCA9IGZuKHsgZXNjYXBlOiBfZXNjYXBlIH0pO1xuXG4gIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uJ3Mgc291cmNlIGJ5IGl0cyBgdG9TdHJpbmdgIG1ldGhvZCBvclxuICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICByZXN1bHQuc291cmNlID0gc291cmNlO1xuICByZXR1cm4gcmVzdWx0O1xufVxuIl19